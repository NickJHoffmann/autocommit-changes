name: Autocommit Github Changes
author: kassett
description: "This GitHub Action allows you to commit changes to git in a runner."

inputs:
  branch:
    description: "The branch to be committed to, or the base_ref if use-pull-request
      is set to true."
    required: true

  github-token:
    description: "The token that the GH cli tool will use."
    required: true

  use-pull-request:
    description: "If 'true', changes will be committed to a separate branch; a PR
      will subsequently be opened from the PR branch. Defaults to 'false'"
    required: false
    default: "false"

  merge-pull-request:
    description: "Automatically merge the pull request created to the base_ref. Defaults
      to 'false'."
    required: false
    default: "false"

  files:
    description: "A list of files to be committed. If no files are defined, changes
      will be found dynamically. This is a comma-separated list."
    required: false
    default: ""

  commit-untracked-files:
    description: "Whether untracked -- i.e. new files -- should be commit as well.
      Defaults to 'false'."
    required: false
    default: "false"

  commit-message:
    description: "The message that signs commits. Defaults to 'Auto-committing files
      [skip ci]'."
    required: false
    default: "Auto-committed files [skip ci]"

  pull-request-title:
    description: "The title of the PR generated by the action. Defaults to 'Auto-generated
      PR'."
    required: false
    default: "Auto-generated PR"

  pull-request-body:
    description: "The body of the pull request. Defaults to 'Pull request opened by
      Github Actions Bot.'"
    required: false
    default: "Pull request opened by Github Actions Bot."

  delete-branch-after-merge:
    description: "Whether branches should be deleted after merging pull requests.
      Defaults to 'false'."
    required: false
    default: "false"

  retries:
    description: "Number of potential retries, useful if there are multiple jobs making
      changes."
    default: "0"
    required: false

  retry-wait-time:
    description: "Number of time (in seconds) to wait between retries."
    default: "30"
    required: false

runs:
  using: composite
  steps:
  - name: Checkout code
    uses: actions/checkout@v4

  - name: Fetch branches
    run: git fetch
    shell: bash

  - name: Autocommit Changes
    id: autocommit_changes
    env:
      GH_TOKEN: ${{ inputs.github-token }}
      AUTOCOMMIT_CHANGES_BRANCH: ${{ inputs.branch }}
      AUTOCOMMIT_CHANGES_USE_PULL_REQUEST: ${{ inputs.use-pull-request }}
      AUTOCOMMIT_CHANGES_MERGE_PULL_REQUEST: ${{ inputs.merge-pull-request }}
      AUTOCOMMIT_CHANGES_FILES: ${{ inputs.files }}
      AUTOCOMMIT_CHANGES_COMMIT_UNTRACKED_FILES: ${{ inputs.commit-untracked-files
        }}
      AUTOCOMMIT_CHANGES_COMMIT_MESSAGE: ${{ inputs.commit-message }}
      AUTOCOMMIT_CHANGES_PULL_REQUEST_TITLE: ${{ inputs.pull-request-title }}
      AUTOCOMMIT_CHANGES_PULL_REQUEST_BODY: ${{ inputs.pull-request-body }}
      AUTOCOMMIT_CHANGES_DELETE_BRANCH_AFTER_MERGE: ${{ inputs.delete-branch-after-merge
        }}
      AUTOCOMMIT_CHANGES_RETRIES: ${{ inputs.retries }}
      AUTOCOMMIT_CHANGES_RETRY_WAIT_TIME: ${{ inputs.retry-wait-time }}
    shell: python
    run: |
      import base64
      import json
      import os
      import time
      import uuid
      from subprocess import run, CalledProcessError

      # Environment variables prefixed by AUTOCOMMIT_CHANGES_
      BRANCH = os.getenv("AUTOCOMMIT_CHANGES_BRANCH")
      USE_PULL_REQUEST = os.getenv("AUTOCOMMIT_CHANGES_USE_PULL_REQUEST")
      MERGE_PULL_REQUEST = os.getenv("AUTOCOMMIT_CHANGES_MERGE_PULL_REQUEST")
      FILES = [
          file for file in os.getenv("AUTOCOMMIT_CHANGES_FILES", "").split(",") if file != ""
      ]
      COMMIT_UNTRACKED_FILES = os.getenv("AUTOCOMMIT_CHANGES_COMMIT_UNTRACKED_FILES")
      COMMIT_MESSAGE = os.getenv("AUTOCOMMIT_CHANGES_COMMIT_MESSAGE")
      PULL_REQUEST_TITLE = os.getenv("AUTOCOMMIT_CHANGES_PULL_REQUEST_TITLE")
      PULL_REQUEST_BODY = os.getenv("AUTOCOMMIT_CHANGES_PULL_REQUEST_BODY")
      DELETE_BRANCH_AFTER_MERGE = os.getenv("AUTOCOMMIT_CHANGES_DELETE_BRANCH_AFTER_MERGE")
      GIT_ROOT = (
          run(args="git rev-parse --show-toplevel", shell=True, capture_output=True, check=True)
          .stdout.decode("utf-8")
          .strip()
      )


      def run_git_command(command: str) -> list[str]:
          output = run(
              args=f"git {command}", shell=True, capture_output=True, check=True, cwd=GIT_ROOT
          )
          return [x for x in output.stdout.decode("utf-8").strip().split("\n") if x != ""]


      def clean_environment():
          run_git_command("stash")
          run_git_command("pull")
          run_git_command("pop")


      def run_gh_command(
          path: str,
          form_arguments: dict | None = None,
          is_delete: bool = False,
          is_put: bool = False,
      ) -> dict | None:
          path = f"/repos/:owner/:repo/{path}"
          command = "gh api"
          if form_arguments is not None:
              command += " -X POST" if not is_put else " -X PUT"
          elif is_delete:
              command += " -X DELETE"

          command += f" {path}"

          if any(isinstance(v, (dict, list)) for v in (form_arguments or {}).values()):
              temporary_path = os.path.join("/tmp", f"{uuid.uuid4()!s}.json")
              with open(temporary_path, "w", encoding="utf-8") as f:
                  json.dump(form_arguments, f, ensure_ascii=False, indent=4)
              command += f" --input {temporary_path}"
          else:
              for k, v in (form_arguments or {}).items():
                  command += f" -f {k}='{v}'"

          output = run(args=command, shell=True, capture_output=True, check=True, cwd=GIT_ROOT)
          if output.stdout is not None and output.stdout.decode("utf-8").strip() != "":
              return json.loads(output.stdout.decode("utf-8").strip())


      class CommitConflictError(ValueError):
          def __init__(self, message: str):
              super().__init__(message)


      class ChangedFile:
          def __init__(self, path: str):
              self.path = path
              self.encoding = "utf-8"
              self.blob_sha = None
              self.is_delete = False

              # Read the file in binary mode and encode to Base64
              try:
                  with open(os.path.join(GIT_ROOT, self.path), "rb") as f:
                      self.content = base64.b64encode(f.read()).decode("utf-8")
              except FileNotFoundError:
                  self.is_delete = True

              if not self.is_delete:
                  self.create_blob()

          def create_blob(self):
              response = run_gh_command(
                  "git/blobs", {"encoding": "base64", "content": self.content}
              )
              self.blob_sha = response["sha"]

          def as_dict(self):
              return {
                  "path": self.path,
                  "mode": "100644",
                  "type": "blob",
                  "sha": self.blob_sha if not self.is_delete else None,
              }


      class GitCommitter:
          def __init__(
              self,
              branch: str,
              files: list[str] | None = None,
              commit_untracked_files: bool = False,
              use_pull_request: bool = False,
              merge_pull_request: bool = False,
              delete_branch_after_merge: bool = True,
          ):
              self.use_pull_request = use_pull_request
              self.merge_pull_request = merge_pull_request
              self.delete_branch_after_merge = delete_branch_after_merge
              self.original_branch = branch
              self.working_branch = branch
              self.commit_untracked_files = commit_untracked_files
              self.latest_sha = None
              self.files = files
              self.changed_files = []

          def find_files(self):

              self.files = [
                  f for f in run_git_command(f"diff --name-only") if f != ""
              ]
              if self.commit_untracked_files:
                  self.files.extend(
                      [
                          f
                          for f in run_git_command("ls-files --others --exclude-standard")
                          if f != ""
                      ]
                  )

          def create_new_branch(self):
              new_branch = f"{self.original_branch}-autocommit-{int(time.time())}"
              run_gh_command(
                  "git/refs", {"ref": f"refs/heads/{new_branch}", "sha": self.latest_sha}
              )
              self.working_branch = new_branch

          def get_working_tree(self):
              output = run_gh_command(f"git/trees/{self.latest_sha}")
              return output["sha"]

          def commit_the_tree(self, tree: str) -> str:
              arguments = {
                  "parents": [self.latest_sha],
                  "tree": tree,
                  "message": COMMIT_MESSAGE,
              }
              try:
                  output = run_gh_command("git/commits", arguments)
              except CalledProcessError:
                  raise CommitConflictError(f"The tree is not updated with the remote.")
              return output["sha"]

          def commit_to_branch(self, sha: str):
              try:
                  run_gh_command(f"git/refs/heads/{self.working_branch}", {"sha": sha})
              except CalledProcessError:
                  raise CommitConflictError(f"The tree is not updated with the remote.")

          def open_pull_request(self):
              return run_gh_command(
                  "pulls",
                  {
                      "head": self.working_branch,
                      "base": self.original_branch,
                      "title": PULL_REQUEST_TITLE,
                      "body": PULL_REQUEST_BODY,
                  },
              )["number"]

          def merge_pr(self, number: int):
              try:
                  run_gh_command(
                      f"pulls/{number}/merge",
                      {"commit_title": PULL_REQUEST_TITLE, "commit_message": COMMIT_MESSAGE},
                      is_put=True,
                  )
              except CalledProcessError:
                  raise CommitConflictError(f"The tree is not updated with the remote.")
              if self.delete_branch_after_merge:
                  run_gh_command(f"git/refs/heads/{self.working_branch}", is_delete=True)

          def create_new_tree(self, base_tree: str) -> str:
              arguments = {
                  "base_tree": base_tree,
                  "tree": [c.as_dict() for c in self.changed_files],
              }
              try:
                  output = run_gh_command("git/trees", arguments)
              except CalledProcessError:
                  raise CommitConflictError(f"The tree is not updated with the remote.")
              return output["sha"]

          def run(self):
              sha = run_gh_command(f"commits/{self.original_branch}")["sha"]
              if sha is None:
                  raise ValueError("Why is this None")
              self.latest_sha = sha
              if not self.files:
                  self.find_files()
              self.changed_files = [ChangedFile(file) for file in self.files]

              if self.use_pull_request:
                  self.create_new_branch()

              current_tree = self.get_working_tree()
              new_tree = self.create_new_tree(current_tree)
              new_commit_sha = self.commit_the_tree(new_tree)
              self.commit_to_branch(new_commit_sha)
              if self.use_pull_request:
                  pr_number = self.open_pull_request()
                  if self.merge_pull_request:
                      self.merge_pr(pr_number)


      def main():
          if BRANCH is None:
              raise ValueError("A branch must be specified via the inputs to the action.")

          gc = GitCommitter(
              branch=BRANCH,
              files=FILES,
              commit_untracked_files=COMMIT_UNTRACKED_FILES == "true",
              use_pull_request=USE_PULL_REQUEST == "true",
              merge_pull_request=MERGE_PULL_REQUEST == "true",
              delete_branch_after_merge=DELETE_BRANCH_AFTER_MERGE == "true",
          )

          try:
              gc.run()
          except CommitConflictError:
              clean_environment()
              gc.run()


      if __name__ == "__main__":
          main()
